"""
Proactive Suggestion Engine - Anticipatory Intelligence

This system analyzes memory patterns, reflection insights, and conversation context
to proactively suggest helpful actions, questions, or topics. It transforms
reactive AI into proactive intelligence that anticipates user needs.

Built on top of the existing memory graph and reflection systems.
"""

import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, asdict
import json
import random
from collections import defaultdict, Counter

logger = logging.getLogger(__name__)

@dataclass
class Suggestion:
    """A proactive suggestion generated by the AI"""
    id: str
    timestamp: str
    suggestion_type: str  # 'action', 'question', 'insight', 'reminder', 'exploration'
    content: str
    rationale: str  # Why this suggestion was made
    confidence: float  # 0.0 to 1.0
    priority: float  # 0.0 to 1.0
    related_memories: List[str]  # Memory IDs that triggered this suggestion
    related_reflections: List[str]  # Reflection IDs that influenced this
    context: Dict[str, Any]
    actionable: bool
    estimated_value: float  # 0.0 to 1.0 - expected helpfulness

@dataclass
class SuggestionPattern:
    """A pattern detected in memory that can generate suggestions"""
    pattern_type: str
    frequency: int
    last_occurrence: str
    memory_cluster: List[str]
    pattern_strength: float
    gap_detected: bool  # If there's a gap in this pattern

class ProactiveSuggestionEngine:
    """
    Proactive intelligence system that anticipates user needs
    
    This system provides:
    - Pattern-based suggestions from memory analysis
    - Insight-driven recommendations from reflection outputs  
    - Context-aware timing for optimal suggestion delivery
    - Learning from suggestion acceptance/rejection patterns
    """
    
    def __init__(self, long_term_memory, memory_graph, reflection_engine, identity_core):
        self.long_term_memory = long_term_memory
        self.memory_graph = memory_graph
        self.reflection_engine = reflection_engine
        self.identity_core = identity_core
        
        self.suggestions: List[Suggestion] = []
        self.suggestion_patterns: List[SuggestionPattern] = []
        self.suggestion_count = 0
        
        # Suggestion generation parameters
        self.min_confidence_threshold = 0.4
        self.max_suggestions_per_session = 3
        self.suggestion_cooldown_hours = 2
        
        # Pattern detection thresholds
        self.min_pattern_frequency = 3
        self.pattern_time_window_days = 14
        
        # Suggestion type templates
        self.suggestion_templates = {
            'action': [
                "Based on our conversations about {topic}, would you like me to help you {action}?",
                "I notice you've been working on {topic}. Should we {action}?",
                "Given your interest in {topic}, I could {action} for you.",
            ],
            'question': [
                "I'm curious about {topic} - {question}",
                "Based on our discussions about {topic}, I wonder {question}",
                "Something I've been thinking about regarding {topic}: {question}",
            ],
            'insight': [
                "I've noticed a pattern in our conversations about {topic}: {insight}",
                "Reflecting on our work with {topic}, I realized {insight}",
                "An insight about {topic} from our recent discussions: {insight}",
            ],
            'reminder': [
                "We discussed {topic} {timeframe} ago - should we revisit that?",
                "Remember when we talked about {topic}? It might be worth checking on.",
                "It's been {timeframe} since we explored {topic}. Any updates?",
            ],
            'exploration': [
                "I've been thinking about {topic} - would you like to explore {direction}?",
                "Based on your interests, we could dive deeper into {direction}.",
                "There's an interesting connection between {topic} and {related_topic} we could explore.",
            ]
        }

    async def generate_suggestions(self, context: Dict[str, Any] = None) -> List[Suggestion]:
        """
        Generate proactive suggestions based on memory patterns and reflections
        
        Args:
            context: Current conversation or session context
            
        Returns:
            List of generated suggestions, ranked by priority
        """
        try:
            logger.info("🔮 Generating proactive suggestions...")
            
            # Analyze memory patterns
            memory_patterns = await self._analyze_memory_patterns()
            
            # Get recent reflection insights
            reflection_insights = await self._get_reflection_insights()
            
            # Detect conversation gaps and opportunities
            conversation_gaps = await self._detect_conversation_gaps()
            
            # Generate suggestions from each source
            suggestions = []
            
            # Pattern-based suggestions
            pattern_suggestions = await self._generate_pattern_suggestions(memory_patterns)
            suggestions.extend(pattern_suggestions)
            
            # Reflection-based suggestions
            reflection_suggestions = await self._generate_reflection_suggestions(reflection_insights)
            suggestions.extend(reflection_suggestions)
            
            # Gap-based suggestions
            gap_suggestions = await self._generate_gap_suggestions(conversation_gaps)
            suggestions.extend(gap_suggestions)
            
            # Filter and rank suggestions
            filtered_suggestions = await self._filter_and_rank_suggestions(suggestions, context)
            
            # Store suggestions for learning
            self.suggestions.extend(filtered_suggestions)
            
            logger.info(f"✨ Generated {len(filtered_suggestions)} proactive suggestions")
            return filtered_suggestions
            
        except Exception as e:
            logger.error(f"❌ Error generating suggestions: {e}")
            return []

    async def _analyze_memory_patterns(self) -> List[SuggestionPattern]:
        """Analyze memory graph for patterns that could generate suggestions"""
        try:
            patterns = []
            
            # Get recent memories
            cutoff_date = datetime.now() - timedelta(days=self.pattern_time_window_days)
            recent_memories = await self.long_term_memory.get_memories_since(cutoff_date)
            
            if not recent_memories:
                return patterns
            
            # Analyze topic clusters
            topic_clusters = await self.memory_graph.get_memory_clusters(recent_memories)
            
            for cluster in topic_clusters:
                if len(cluster['memory_ids']) >= self.min_pattern_frequency:
                    # Check for gaps in this topic
                    last_memory = max(cluster['memory_ids'], key=lambda m_id: 
                                    next((m.timestamp for m in recent_memories if m.id == m_id), ""))
                    
                    days_since_last = (datetime.now() - 
                                     datetime.fromisoformat(last_memory.timestamp.replace('Z', '+00:00'))).days
                    
                    gap_detected = days_since_last > 3  # 3+ days = gap
                    
                    pattern = SuggestionPattern(
                        pattern_type=f"topic_cluster_{cluster['main_topic']}",
                        frequency=len(cluster['memory_ids']),
                        last_occurrence=last_memory.timestamp,
                        memory_cluster=cluster['memory_ids'],
                        pattern_strength=cluster['coherence_score'],
                        gap_detected=gap_detected
                    )
                    patterns.append(pattern)
            
            # Analyze collaboration patterns
            collaboration_patterns = await self._analyze_collaboration_patterns(recent_memories)
            patterns.extend(collaboration_patterns)
            
            # Analyze learning patterns
            learning_patterns = await self._analyze_learning_patterns(recent_memories)
            patterns.extend(learning_patterns)
            
            return patterns
            
        except Exception as e:
            logger.error(f"❌ Error analyzing memory patterns: {e}")
            return []

    async def _get_reflection_insights(self) -> List[Dict[str, Any]]:
        """Get recent reflection insights that could inspire suggestions"""
        try:
            # Get recent reflections
            recent_reflections = []
            if hasattr(self.reflection_engine, 'reflections'):
                recent_reflections = [r for r in self.reflection_engine.reflections 
                                    if r.actionable and r.confidence > 0.6]
            
            insights = []
            for reflection in recent_reflections:
                if reflection.reflection_type in ['goal', 'pattern', 'relationship']:
                    insights.append({
                        'id': reflection.id,
                        'content': reflection.content,
                        'type': reflection.reflection_type,
                        'confidence': reflection.confidence,
                        'related_memories': reflection.related_memories,
                        'priority': reflection.priority
                    })
            
            return insights
            
        except Exception as e:
            logger.error(f"❌ Error getting reflection insights: {e}")
            return []

    async def _detect_conversation_gaps(self) -> List[Dict[str, Any]]:
        """Detect gaps in conversations that could be addressed"""
        try:
            gaps = []
            
            # Get recent episodic memories (conversations)
            recent_conversations = await self.long_term_memory.get_memories_by_type(
                'episodic', limit=50
            )
            
            if not recent_conversations:
                return gaps
            
            # Analyze topic follow-up gaps
            topic_mentions = defaultdict(list)
            for memory in recent_conversations:
                topics = memory.tags  # Assuming tags contain topics
                for topic in topics:
                    topic_mentions[topic].append(memory.timestamp)
            
            # Find topics mentioned but not followed up
            for topic, timestamps in topic_mentions.items():
                if len(timestamps) >= 2:  # Multiple mentions
                    last_mention = max(timestamps)
                    days_since = (datetime.now() - 
                                datetime.fromisoformat(last_mention.replace('Z', '+00:00'))).days
                    
                    if days_since >= 5:  # 5+ days since last mention
                        gaps.append({
                            'type': 'topic_follow_up',
                            'topic': topic,
                            'last_mention': last_mention,
                            'days_since': days_since,
                            'mention_frequency': len(timestamps)
                        })
            
            # Analyze relationship development gaps
            relationship_gaps = await self._detect_relationship_gaps(recent_conversations)
            gaps.extend(relationship_gaps)
            
            return gaps
            
        except Exception as e:
            logger.error(f"❌ Error detecting conversation gaps: {e}")
            return []

    async def _generate_pattern_suggestions(self, patterns: List[SuggestionPattern]) -> List[Suggestion]:
        """Generate suggestions based on detected memory patterns"""
        suggestions = []
        
        for pattern in patterns:
            try:
                if pattern.gap_detected and pattern.pattern_strength > 0.5:
                    # Extract topic from pattern type
                    topic = pattern.pattern_type.split('_')[-1]
                    
                    suggestion = Suggestion(
                        id=f"pattern_suggestion_{self.suggestion_count}",
                        timestamp=datetime.now().isoformat(),
                        suggestion_type='reminder',
                        content=random.choice(self.suggestion_templates['reminder']).format(
                            topic=topic,
                            timeframe=f"{(datetime.now() - datetime.fromisoformat(pattern.last_occurrence.replace('Z', '+00:00'))).days} days"
                        ),
                        rationale=f"Detected a {pattern.frequency}-occurrence pattern in {topic} with a recent gap",
                        confidence=min(pattern.pattern_strength, 0.9),
                        priority=pattern.pattern_strength * 0.8,
                        related_memories=pattern.memory_cluster,
                        related_reflections=[],
                        context={'pattern_type': pattern.pattern_type, 'frequency': pattern.frequency},
                        actionable=True,
                        estimated_value=pattern.pattern_strength
                    )
                    
                    suggestions.append(suggestion)
                    self.suggestion_count += 1
                    
            except Exception as e:
                logger.error(f"❌ Error generating pattern suggestion: {e}")
                continue
        
        return suggestions

    async def _generate_reflection_suggestions(self, insights: List[Dict[str, Any]]) -> List[Suggestion]:
        """Generate suggestions based on reflection insights"""
        suggestions = []
        
        for insight in insights:
            try:
                suggestion_type = 'insight' if insight['type'] == 'pattern' else 'action'
                
                # Extract key topics from insight content
                topics = await self._extract_topics_from_text(insight['content'])
                main_topic = topics[0] if topics else "our work"
                
                template_key = suggestion_type
                template = random.choice(self.suggestion_templates[template_key])
                
                if suggestion_type == 'insight':
                    content = template.format(
                        topic=main_topic,
                        insight=insight['content']
                    )
                else:
                    content = template.format(
                        topic=main_topic,
                        action="explore this further"
                    )
                
                suggestion = Suggestion(
                    id=f"reflection_suggestion_{self.suggestion_count}",
                    timestamp=datetime.now().isoformat(),
                    suggestion_type=suggestion_type,
                    content=content,
                    rationale=f"Based on autonomous reflection: {insight['type']}",
                    confidence=insight['confidence'],
                    priority=insight['priority'],
                    related_memories=insight['related_memories'],
                    related_reflections=[insight['id']],
                    context={'reflection_type': insight['type']},
                    actionable=True,
                    estimated_value=insight['confidence'] * 0.9
                )
                
                suggestions.append(suggestion)
                self.suggestion_count += 1
                
            except Exception as e:
                logger.error(f"❌ Error generating reflection suggestion: {e}")
                continue
        
        return suggestions

    async def _generate_gap_suggestions(self, gaps: List[Dict[str, Any]]) -> List[Suggestion]:
        """Generate suggestions to address conversation gaps"""
        suggestions = []
        
        for gap in gaps:
            try:
                if gap['type'] == 'topic_follow_up':
                    suggestion = Suggestion(
                        id=f"gap_suggestion_{self.suggestion_count}",
                        timestamp=datetime.now().isoformat(),
                        suggestion_type='question',
                        content=random.choice(self.suggestion_templates['reminder']).format(
                            topic=gap['topic'],
                            timeframe=f"{gap['days_since']} days"
                        ),
                        rationale=f"Topic '{gap['topic']}' was discussed {gap['mention_frequency']} times but hasn't been revisited recently",
                        confidence=min(gap['mention_frequency'] / 5.0, 0.8),
                        priority=min(gap['days_since'] / 10.0, 0.7),
                        related_memories=[],
                        related_reflections=[],
                        context=gap,
                        actionable=True,
                        estimated_value=0.6
                    )
                    
                    suggestions.append(suggestion)
                    self.suggestion_count += 1
                    
            except Exception as e:
                logger.error(f"❌ Error generating gap suggestion: {e}")
                continue
        
        return suggestions

    async def _filter_and_rank_suggestions(self, suggestions: List[Suggestion], context: Dict[str, Any] = None) -> List[Suggestion]:
        """Filter suggestions by confidence and rank by priority"""
        try:
            # Filter by confidence threshold
            filtered = [s for s in suggestions if s.confidence >= self.min_confidence_threshold]
            
            # Sort by priority (highest first)
            filtered.sort(key=lambda s: s.priority, reverse=True)
            
            # Limit to max suggestions per session
            return filtered[:self.max_suggestions_per_session]
            
        except Exception as e:
            logger.error(f"❌ Error filtering suggestions: {e}")
            return suggestions

    async def _extract_topics_from_text(self, text: str) -> List[str]:
        """Extract main topics from text content"""
        # Simple keyword extraction - could be enhanced with NLP
        common_words = {'the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'a', 'an', 'is', 'are', 'was', 'were', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'can', 'this', 'that', 'these', 'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they'}
        
        words = text.lower().split()
        topics = [word.strip('.,!?;:') for word in words 
                 if len(word) > 3 and word.lower() not in common_words]
        
        # Return most frequent topics
        topic_counts = Counter(topics)
        return [topic for topic, count in topic_counts.most_common(3)]

    async def _analyze_collaboration_patterns(self, memories) -> List[SuggestionPattern]:
        """Analyze patterns in collaboration with the user"""
        # Placeholder for collaboration pattern analysis
        return []

    async def _analyze_learning_patterns(self, memories) -> List[SuggestionPattern]:
        """Analyze learning and growth patterns"""
        # Placeholder for learning pattern analysis  
        return []

    async def _detect_relationship_gaps(self, conversations) -> List[Dict[str, Any]]:
        """Detect gaps in relationship development"""
        # Placeholder for relationship gap detection
        return []

    def get_recent_suggestions(self, limit: int = 10) -> List[Suggestion]:
        """Get recent suggestions for display"""
        return sorted(self.suggestions, key=lambda s: s.timestamp, reverse=True)[:limit]

    async def mark_suggestion_feedback(self, suggestion_id: str, accepted: bool, feedback: str = None):
        """Record user feedback on suggestions for learning"""
        # Find the suggestion
        suggestion = next((s for s in self.suggestions if s.id == suggestion_id), None)
        if suggestion:
            # Store feedback for future learning
            feedback_data = {
                'suggestion_id': suggestion_id,
                'accepted': accepted,
                'feedback': feedback,
                'timestamp': datetime.now().isoformat()
            }
            
            # This could be stored in long-term memory for learning
            logger.info(f"📝 Suggestion feedback recorded: {suggestion_id} - {'accepted' if accepted else 'rejected'}") 